[[truisa-rv32t]]
== RV32T/RV64T的标记指针

在RV32T/RV64T中，线性地址采用标记指针(Tagged Pointer)格式，将内存对象的元数据信息以压缩编码的形式保存在线性地址高TLEN的未使用位域中。
标记指针由两部分组成：标记(Tag)位域和线性地址位域(Address)。
在RV32T中，标记位域是8比特，线性地址是24比特。在Rv64T中，标记位域是16比特，线性地址是64比特。

四种类型的标记指针：

描述符表标记指针：在对象描述符表中存在相对应的描述符表项，采用形心标记的哈希对象表。通过S-Radix和Address寄存器形心标记。只能由Malloc等库函数处理，不能由TAGPTR直接生成。

描述符寄存器标记指针：存在相对应的Reg描述符寄存器，RV32T共有8个，RV64T共有16个，通过Reg位域直接表示。只能由Malloc等库函数处理，不能由TAGPTR直接生成。

固定尺寸标记指针：F-Radixde2的幂次方大小的内存对象。TAGPTR标记修改指令可以生成的标记指针，必须符合权限单调性原则。此类指针应该由编译保证不会产生时间内存例外。

固定类型标记指针：基本类型的指针，PtrType指定指针类型，指针类型具有固定的尺寸和对齐。固定类型标志指针不能进行指针算数运算。TAGPTR可以生成的标记指针，必须符合权限单调性原则。

下图阐明了RV32T/RV64T的线性地址格式，表1解释了标记各个字段的含义。

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV32T标记指针格式*
      |31   |30|29 |28|27|26   |25   |24       |23|22|21|20|19|18|17|...|...|...|7|6|5|4|3|2|1|0
   8+^|0x00                                18+^|Address
   1+^|0 5+^|S-Radix        1+^|W 1+^|R    18+^|Address 
   1+^|0 2+^|11 3+^|Reg     1+^|W 1+^|R    18+^|Address 
   1+^|1 5+^|F-Radix        1+^|W 1+^|NT   18+^|Address
   1+^|1 2+^|11 3+^|PtrType 1+^|W 1+^|RA   18+^|Address
   8+^|0xFF                                18+^|Address
|===

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV64T标记指针格式*
      |63   |62|61 |60|...|57  |56   |55    |54|53|...|48 |47|46|45|44|...|...|7|6|5|4|3|2|1|0
  12+^|0x0000                                         14+^|Address
   1+^|0 5+^|S-Radix        1+^|W 1+^|R  4+^|Key      14+^|Address 
   1+^|0 2+^|11 3+^|Reg     1+^|W 1+^|R  4+^|Reserved 14+^|Address 
   1+^|1 5+^|F-Radix        1+^|W 1+^|NT 4+^|Reserved 14+^|Address
   1+^|1 2+^|11 3+^|PtrType 1+^|W 1+^|RA 4+^|Reserved 14+^|Address
  12+^|0xFFFF                                         14+^|Address
|===

RV32T标记

如果标记位域是0x00或者0xFF，则表示该指针为兼容指针，在安全模式下表示指针非法。

线性地址最高位如果清0，表示标记位域是描述符表标记指针。线性地址最高位如果置1，表示标记位域是固定尺寸标记指针模式。

W/X/R表示读写执行权限

S-Radix表示Address所在内存对象的Centroid-ID是2的S-Radix幂次方大小和对齐内存块的中间点地址。
S-Radix必须大于0，并且必须小于24。

当S-Radix位域大于等于24时，指针是描述符寄存器标记指针，Reg位域表示8个描述符Reg寄存器的索引。

F-Radix表示Address所在内存对象是固定大小的内存块，块大小和对齐都是2的F-Radix幂次方。F-Radix必须小于24.

当F-Radix位域大于24时，PtrType表示指针类型类(TODO)，不能进行指针运算操作。PtrType不能等于7.
PtrType
0: 1B
1: 2B
10: 3B
100: 4B
...
101: Func Pointer
110: Pointer usize

NT表示Non-Terminal, 支持Saturation；

RA表示指针（Raw Pointer），不可以可以进行偏移计算；

Reg 转换到 S-Radix 转换到 F-Radix 转换到 PtrType

RV64T标记：

如果标记位域是0x0000或者0xFFFF，则表示该指针为兼容指针，在安全模式下表示指针非法。

S-Radix必须大于0，并且必须小于48。当S-Radix位域大于等于48时，Reg表示16个对象描述符寄存器索引。

F-Radix必须小于48.当F-Radix位域大于48时，PtrType指针类型，不能进行指针运算操作，PtrType不能等于15.

Key表示MallocID，说明该对象所在的内存区域被内存分配的次数，用来解决Use-After-Free问题。当Key达到最大值时，该内存区域所在的内存不能在用来分配给相同尺寸的对象了。

未来预留设计：

Hints用于指示微体系结构的特性

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV32T对象描述符格式*
      |31   |30    |29    |28    |27    |26    |25   |24     |23|22|21|20|19|18|17|...|...|...|7|6|5|4|3|2|1|0
   1+^|V 1+^|NT 1+^|IN 1+^|FR 1+^|W  1+^|R  1+^|X 1+^|PL 18+^|Bound Address 
   1+^|P 5+^|PageSize  2+^|Reserved                      18+^|Base Address 

|===

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV64T对象描述符格式*
      |63   |62    |61    |60    |59   |58    |57   |56    |55|54    |53|...|48 |47|46|45|...|...|7|6|5|4|3|2|1|0
   1+^|V 1+^|NT 1+^|IN 1+^|FR 1+^|W 1+^|R  1+^|X 2+^|PL 4+^|Key  13+^|Bound Address 
   1+^|P 6+^|PageSize                            6+^|Reserved    13+^|Base Address 
|===

V: Valid，描述符表项是否有效。

NT: Null-Terminal，是否是‘空’表示结尾的流数据（如字符串）。

IN: Initial，是否已经初始化

FR: Freed，已经被释放，不能进行读写，需要额外的机制，决定是否能被释放。

XRW: Execute/Read/Write

预留未来应用。

PL：特权级，Object Privilege Level (OPL) (Future，默认为3)

Key: 可以表示该对象所在的内存区域被内存分配的次数，用来解决Use-After-Free问题。当Key达到最大值时，该内存区域所在的内存不能在用来分配给相同尺寸的对象了。或者其他Lock-key应用。

P: Page/Range，虚实地址转换是采用区间表还是页表，PageSize表示在页表模式下的页大小。

Reserved: Hints 用于指示微体系结构的特性（Future）

<<<
== TruISA-RISC-V 指令编码

[%autowidth.stretch,float="center",align="center",cols="^2m,^2m,^2m,^2m,<2m,>3m, <4m, >4m, <4m, >4m, <4m, >4m, <4m, >4m, <6m"]
|===
    |31 |27 |26  |25    |24 |  20|19  |  15| 14  |  12|11      |      7|6   |   0|
15+^|*RV32T Base Instruction Set*
 6+^|imm[11:0]                2+^|rs1   2+^|101    2+^|rd           2+^|0001111 <|INCPTRI
 6+^|imm[11:0]                2+^|rs1   2+^|110    2+^|rd           2+^|0001111 <|TAGPTRI
 6+^|imm[11:0]                2+^|rs1   2+^|111    2+^|rd           2+^|0001111 <|LPTR
 4+^|imm[11:5]      2+^|rs2   2+^|rs1   2+^|111    2+^|imm[4:0]     2+^|0100011 <|SPTR
 4+^|0100000        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|SUBPTR
 4+^|0000100        2+^|00000 2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|PTRTAG
 4+^|0000101        2+^|00000 2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|PTRINT
 4+^|0000110        2+^|00000 2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|PTRBASE
 4+^|0100110        2+^|00000 2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|PTRBOUND 
 4+^|0000111        2+^|00000 2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|PTROID
 4+^|0001100        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|SLTUPTR
 4+^|0010100        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|INCPTR
 4+^|0010100        2+^|00000 2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|MVPTR
 4+^|0110100        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|DECPTR
 4+^|0011000        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|TAGPTR
 4+^|0011001        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|INTPTR
 4+^|0011010        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|BOUNDPTR
 4+^|0011011        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|ANDPERM
 4+^|0011100        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|LDOLBD
 4+^|0111100        2+^|rs2   2+^|rs1   2+^|011    2+^|rd           2+^|0001111 <|LDOLBI
 4+^|0011101        2+^|00000 2+^|rs1   2+^|011    2+^|00000        2+^|0001111 <|INVOLBD
 4+^|0111101        2+^|00000 2+^|rs1   2+^|011    2+^|00000        2+^|0001111 <|INVOLBI
|===

<<<
== RV32T/RV64T 例外
地址例外。address secure fault

标记例外：如果标记中S-Radix全0；PtrType全1；如果指针计算结果的标记与源指针（rs1）的标记不相同则产生标记完整性例外。

越界例外：如果在ld/st指令的地址超出rs1定义的内存对象边界，则产生边界溢出例外。

偏移例外：固定类型指针进行指针算数运算，产生偏移例外，裸指（RA）针除外。

单调例外：TAGPTR/RDXPTR指令的目标内存区域超出原内存对象内存区域的例外

访问例外。access secure fault

读写例外：利用read-only(W=0)指针执行store类指令。指令内存操作与描述符权限不符。

类型例外：PtrType与指令类型不符。

释放例外：对已经释放的对象进行访问

键锁例外：key不相同。

初值例外：对未初始化的对象进行访问。

未来预留：

特权例外：Max(RPL, CPL) < = OPL


<<<
== RV32T/RV64T 指令详解

<<<
== RV32T/RV64T CSR详解

3.1.1. Machine ISA Register misa
|===
|Bit       |Character |Description
|19        |T         |RV32/64T base ISA
|===

3.1.15. Machine Cause Register (mcause)
|===
|Interrupt |Exception |priority |Code Description
|0         |32        |as 0     |Instruction address secure fault
|0         |33        |as 1     |Instruction access  secure fault
|0         |36        |as 4     |Load address secure fault
|0         |37        |as 5     |Load access  secure fault
|0         |38        |as 6     |Store/AMO address secure fault
|0         |39        |as 7     |Store/AMO access  secure fault
|0         |44        |as 0     |Instruction object fault
|0         |45        |as 4     |Load object fault
|0         |47        |as 6     |Instruction object fault
|===

3.1.18. Machine Environment Configuration Register (menvcfg)

|===
|Bit       |Character |Description
|16        |MSICTE    |Memory Safety Instruction Trap Enable
|17        |MSTE      |Memory Safety Data Check Enable
|18        |MSDCTE    |Memory Safety Data Trap Enable

|===

待定设计：

8个 Object Descriptor CSR in RV32T (Future)

16个 Ojbect Descriptor CSR in RV64T (Future)
