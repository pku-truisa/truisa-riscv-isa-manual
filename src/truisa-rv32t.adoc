[[truisa-rv32t]]
== RV32T/RV64T的标记指针

RV32T/RV64T的非特权和特权功能继承Cheriot的定义，但权能指针（Capability）采用Tagged Pointer形式，指针位宽与RISC-V ABI兼容。

在RV32T/RV64T中，地址采用标记指针(Tagged Pointer)格式，将内存对象的元数据信息以压缩编码的形式保存在线性地址高TLEN的未使用位域中。
标记指针由两部分组成：指针标记(PtrTag)位域和线性地址位域(Address)。
在RV32T中，标记位域是6比特，TLEN=6，线性地址是26比特。在Rv64T中，标记位域是7比特，TLEN=7，线性地址是57比特。
在寄存器堆中，每个标记指针还隐含 1 比特的存储标记位（MemTag），实现指针一致行检查。

TruISA定义了2种类型的标记指针：

固定尺寸标记指针（F-Radix）：F-Radix指定的2的幂次方大小的内存对象。用户程序可以通过标记修改指令生成的标记指针，必须符合权限单调性原则。

描述符表标记指针（S-Radix)：在对象描述符表中存在相对应的描述符表项，采用形心标记的哈希对象表。通过S-Radix和Address有硬件计算形心标记。该类型指针只能由Malloc等库函数生成，不能由用户程序直接生成。描述符表也有库函数和操作系统管理。

基本原则：对小数据对象和规整数据对象采用F-Radix指针类型，对大数据对象和飞规整数据对象采用S-Radix类型。

下图阐明了RV32T/RV64T的标记指针格式，表1解释了标记各个字段的含义。

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV32T标记指针格式 (26比特线性地址）*
      |31      |30|29|28|27|26     |25|24|23|22|21|20|19|18|17|...|...|...|7|6|5|4|3|2|1|0
   6+^|0x00                    20+^|Address   
   1+^|0    5+^|F-Radix        20+^|Address   
   1+^|1    5+^|0x00           20+^|Address 
   1+^|1    5+^|S-Radix        20+^|Address 
   6+^|0x3F                    20+^|Address
|===

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV64T标记指针格式（57比特线性地址）*
      |63      |62|61 |60|58|59|57     |56|55|...|...|49|48|47|46|45|...|...|7|6|5|4|3|2|1|0
   7+^|0x00                        19+^|Address
   1+^|0    6+^|F-Radix            19+^|Address 
   1+^|1    6+^|0x00               19+^|Address
   1+^|1    6+^|S-Radix            19+^|Address
   7+^|0x7F                        19+^|Address
|===

RV32T标记说明：

如果标记位域是0x00或者0x3F，则表示该指针为整数，非标记指针。否则，

指针最高位如果置1，表示标记位域是描述符表标记指针。线性地址最高位如果清0，表示标记位域是固定尺寸标记指针模式，其中：

S-Radix表示Address所在内存对象的Centroid标识是2的S-Radix幂次方大小和对齐的内存块中间点地址。

S-Radix大于0，小于等于26，否则是非法标记，产生标记违例。

F-Radix表示Address所在内存对象是固定大小的内存块，块大小和对齐都是2的F-Radix幂次方。

F-Radix大于0，小于等于26，否则是非法标记，产生标记违例。

标记位域是0x20，表示字节标记指针，不允许进行指针运算。

RV64T标记指针说明：

如果标记位域是0x00或0x7F，则表示该指针为线性地址，非标记指针。否则，

S-Radix大于0，小于等于58，否则是非法标记，产生标记违例。

F-Radix大于0，小于等于58，否则是非法标记，产生标记违例。

标记位域是0x40，表示字节标记指针，不允许进行指针运算。

下表表示RV32T和RV64T的描述符格式(草案，第一阶段，只保留Bound, Base, High，其他权限部分先不实现)

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV32T对象描述符格式*
      |31   |30    |29    |28    |27    |26    |25   |24      |23|22|21|20|19|18|17|...|...|...|7|6|5|4|3|2|1|0
   1+^|V 1+^|IN 1+^|FR 1+^|X  1+^|R  1+^|W 20+^|Limit Address 
   6+^|Reserved                            20+^|Base Address 
|===

{empty} +
[%autowidth.stretch,float="center",align="center",cols="26*"]
|===
  26+^|*RV64T对象描述符格式*
      |63   |62    |61    |60    |59   |58    |57     |56|55|54|53|...|48 |47|46|45|...|...|7|6|5|4|3|2|1|0
   1+^|V 1+^|IN 1+^|FR 1+^|X 1+^|R  1+^|W  1+^|PL 19+^| Address 
   7+^|Reserved                                   19+^|Base Address 
|===

V: Valid，描述符表项是否有效。

IN: Initial，对象是否已经初始化

FR: Freed，对象是否已经被释放。

X、W、R: Execute/Read/Write

PL：特权级，Object Privilege Level (OPL) (Future，默认RV32T为1、RV64T为3，即用户权限)

== TruISA-RISC-V的指令
去除Cheri-RISC-V中所有关于Perm, Type, Seal, Flags相关的指令。

== TruISA-RISC-V的例外
标记指针运算指令如果产生错误，结果将Tag位域(High)符号扩展，清全0或者置全1

<<<
== TruISA-RISC-V 指令编码

[%autowidth.stretch,float="center",align="center",cols="^2m,^2m,^2m,^2m,<2m, >3m, <4m, >4m, <4m, >4m, <4m, >4m, <4m, >4m, <6m"]
|===
    |31 | | |25    |24 |  20|19  |  15| 14  |  12|11      |       7| 6   |   0|
15+^|*RV32T Base Instruction Set*
 4+^|1111111        2+^|00010 2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CGetBase
 4+^|1111111        2+^|00011 2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CGetLen
 4+^|1111111        2+^|00100 2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CGetMemTag
 4+^|1111111        2+^|01000 2+^|rs1   2+^|011    2+^|cd           2+^| 0001111 <|CRoundRepresentableLength
 4+^|1111111        2+^|01001 2+^|rs1   2+^|011    2+^|cd           2+^| 0001111 <|CRepresentableAlignmentMask
 4+^|1111111        2+^|01010 2+^|cs1   2+^|011    2+^|cd           2+^| 0001111 <|CMove
 4+^|1111111        2+^|01011 2+^|cs1   2+^|011    2+^|cd           2+^| 0001111 <|CClearMemTag
 4+^|1111111        2+^|01111 2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CGetAddr
 4+^|1111111        2+^|10111 2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CGetHigh
 4+^|1111111        2+^|11000 2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CGetLimit
 4+^|0000001        2+^|scr   2+^|cs1   2+^|011    2+^|cd           2+^| 0001111 <|CSpecialRW
 4+^|0001000        2+^|rs2   2+^|cs1   2+^|011    2+^|cd           2+^| 0001111 <|CSetBounds
 4+^|0010000        2+^|rs2   2+^|cs1   2+^|011    2+^|cd           2+^| 0001111 <|CSetAddr
 4+^|0010001        2+^|rs2   2+^|cs1   2+^|011    2+^|cd           2+^| 0001111 <|CIncAddr
 4+^|0010110        2+^|rs2   2+^|cs1   2+^|011    2+^|cd           2+^| 0001111 <|CSetHigh
 4+^|0100000        2+^|cs2   2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CTestSubset
 4+^|0100010        2+^|cs2   2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CSetEqualExact
 4+^|0110100        2+^|cs2   2+^|cs1   2+^|011    2+^|rd           2+^| 0001111 <|CSub
 6+^|imm[11:0]                2+^|rs1   2+^|100    2+^|cd           2+^| 0001111 <|CIncAddrImm
 6+^|imm[11:0]                2+^|rs1   2+^|101    2+^|cd           2+^| 0001111 <|CSetBoundsImm
 8+^|imm[31:12]                         2+^|110    2+^|cd           2+^| 0001111 <|AUICGP
 6+^|imm[11:0]                2+^|cs1   2+^|111    2+^|cd           2+^| 0000011 <|CLC
 4+^|imm[11:5]      2+^|cs2   2+^|cs1   2+^|111    2+^|imm[4:0]     2+^| 0100011 <|CSC
|===

<<<
== RV32T/RV64T 例外
 
* 标记检查TC：如果标记全0或者全1，标记设置指令的目标内存区域超出原内存对象内存区域的单调违例。

* 越界检查BC：如果在CIncAddr等指针运算指令和ld/st类指令的地址运算超出cs1定义的内存对象边界，则产生边界溢出违例。如果指针计算结果cd的标记与源指针（cs1）的标记不相同则产生标记完整性违例。

* 访存指令违例处理：Debug模式发出例外，否则无任何操作。

* 如果标记指针生成指令产生为例，目标cd的High符号扩展，产生整数地址。

<<<
== RV32T/RV64T 指令详解

1. 指针运算指令：

* CIncAddr/CIncAddrImm：进行指针运算，结果位指针类型，并进行标记检查和越界检查。如违例，符号扩展产生整数地址。

* CSub/CTestSubset/CSetEqualExact：只对线性地址进行减法和无符号比较操作，结果为整数类型，不进行任何检查。

* CMove=：简单的复制操作，结果为指针类型，不进行任何检查。

* CClearTag: 简单Tag清0，不做任何违例检查。

2. 标记产生指令

* CSetHigh/CSetBounds/CSetBoundImm：将源操作数的低TLEN位数据复制到目的操作数的高TLEN位中，进行标记检查，越界检查和越权检查，保证单调性。

3. 标记提取指令：

* 将相应位域复制到目标的最低位。

4. 访存指令：

* 进行相应的访存操作，进行所有检查，如果DATE是1则发出例外，否则如果指针内或者描述符中NT是1则越上界访问上界越下界访问下界，否则无任何操作。